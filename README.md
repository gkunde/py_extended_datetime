# Extended DateTime

> **IMPORTANT:**
>
> Please consider this project as beta release. Breaking changes may not always be documented or logged.

An extension library for Python's built-in datetime class. Providing additional methods to perform common date calculations, and provide attributes related to the object's values.

The goal of this library is to provide convenience methods to a datetime object, reducing the number additional modules and packages needed to perform similar operations.

## Features
* Inherits from datetime, making any object generated by this class compatible with existing code expecting to work with a datetime object.
* Only uses Python's built in libraries. Beneficial to projects attempting to reduce package dependencies.

## Examples
### Adding dates
```python
current_date = ExtendedDateTime(datetime.utcnow())

# equivalent to current_date + timedelta(days=1)
tomorrow = current_date.date_add(days=1) 

# There are even months!
next_month = current_date.date_add(months=1)

# equivalent to `current_date + timedelta(days=365)`, but accounting for leap years
next_year = current_date.date_add(years=1)
```

## Important: Adding years or months
The ability to add years and months assumes the calculation is made from the same starting point. This means if you need to calculate dates multiple months or years into the future or past, that you always use the original object, and alter the the number of months or years provided.

When adding months or years, the day of month will change if the month of the result does not contain as many days as the original month. This means if you have a date like the 31st of March, and add one month, you will have a result with the 30th of April. This is applied to all end of month scenarios and is why it is recommended to use the original object to calculate needed dates. That will ensure that if you start with the 31st of March, and require April and May, those dates will have days of the month being the 30th and 31st respectively. If you were to use the result for April, to calculate May, you will end up with the 30th of May.

To avoid the target date from sliding, always use your original object to generate each date in the series.
